/**
 * Feng Shui Utility Functions
 * ZC2.5 Feng Shui Remedies and Guidance Implementation
 *
 * This file contains mathematical and utility functions for Feng Shui calculations,
 * including compass calculations, elemental compatibility, and Flying Stars analysis.
 */

const { FENG_SHUI_CONSTANTS, BAGUA_AREAS, FIVE_ELEMENTS, FLYING_STARS } = require('./feng-shui-constants');

/**
 * Calculate precise compass direction from coordinates
 * @param {number} latitude - Latitude of current position
 * @param {number} longitude - Longitude of current position
 * @param {number} targetLat - Latitude of target position
 * @param {number} targetLon - Longitude of target position
 * @returns {number} Bearing in degrees (0-360)
 */
function calculateCompassDirection(latitude, longitude, targetLat, targetLon) {
    const dLon = (targetLon - longitude) * Math.PI / 180;
    const lat1 = latitude * Math.PI / 180;
    const lat2 = targetLat * Math.PI / 180;

    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);

    let bearing = Math.atan2(y, x) * 180 / Math.PI;
    bearing = (bearing + 360) % 360;

    return Math.round(bearing * 10) / 10; // Round to 1 decimal place
}

/**
 * Normalize compass direction to 0-360 range
 * @param {number} direction - Direction in degrees
 * @returns {number} Normalized direction
 */
function normalizeDirection(direction) {
    return ((direction % 360) + 360) % 360;
}

/**
 * Calculate Bagua area from compass direction
 * @param {number|null} direction - Compass direction in degrees
 * @returns {string} Bagua area name
 */
function calculateBaguaArea(direction) {
    if (direction === null || direction === undefined) return 'Center';

    const normalizedDirection = normalizeDirection(direction);

    // Bagua sector calculation (45-degree sectors)
    const sectorSize = 45;
    const sector = Math.floor((normalizedDirection + 22.5) / sectorSize) % 8;

    const baguaNames = ['Kan', 'Gen', 'Zhen', 'Xun', 'Li', 'Kun', 'Dui', 'Qian'];
    return baguaNames[sector];
}

/**
 * Calculate elemental compatibility score
 * @param {string} element1 - First element
 * @param {string} element2 - Second element
 * @returns {number} Compatibility score (0.0-1.0)
 */
function calculateElementalCompatibility(element1, element2) {
    if (element1 === element2) return 1.0; // Same element: harmonious
    if (FIVE_ELEMENTS[element1].generates === element2) return 0.9; // Generates: supportive
    if (FIVE_ELEMENTS[element1].generatedBy === element2) return 0.8; // Generated by: nurturing
    if (FIVE_ELEMENTS[element1].controls === element2) return 0.3; // Controls: challenging
    if (FIVE_ELEMENTS[element1].controlledBy === element2) return 0.4; // Controlled by: weakened

    return 0.6; // Neutral relationship
}

/**
 * Calculate Flying Star influence score
 * @param {number} starNumber - Star number (1-9)
 * @param {number} period - Current period
 * @param {object} location - Location context
 * @returns {number} Influence score (0.1-1.0)
 */
function calculateFlyingStarInfluence(starNumber, period, location) {
    const star = FLYING_STARS[starNumber];
    if (!star) return 0.5;

    // Base influence based on star nature
    let influence = 0.5;

    switch (star.nature) {
        case 'Wealth': influence = 0.9; break;
        case 'Heavenly': influence = 0.8; break;
        case 'Future Prosperity': influence = 0.8; break;
        case 'Romantic': influence = 0.7; break;
        case 'Violent': influence = 0.2; break;
        case 'Sickly': influence = 0.3; break;
        case 'Argumentative': influence = 0.4; break;
        default: influence = 0.5;
    }

    // Adjust for current period
    const periodCompatibility = calculatePeriodCompatibility(starNumber, period);
    influence = influence * 0.7 + periodCompatibility * 0.3;

    return Math.max(0.1, Math.min(1.0, influence));
}

/**
 * Calculate period compatibility for Flying Stars
 * @param {number} starNumber - Star number
 * @param {number} period - Current period
 * @returns {number} Compatibility score
 */
function calculatePeriodCompatibility(starNumber, period) {
    // Simplified calculation - in practice would use complex formulas
    const basePeriod = Math.floor((period - 1864) / 20) + 1; // 20-year cycles
    const periodStar = ((basePeriod - 1) % 9) + 1;

    // Stars 8 and 9 are generally favorable
    if (starNumber === 8 || starNumber === 9) return 0.8;

    // Stars 2, 3, 7 are generally unfavorable
    if (starNumber === 2 || starNumber === 3 || starNumber === 7) return 0.3;

    // Other stars depend on period
    return starNumber === periodStar ? 0.9 : 0.5;
}

/**
 * Get star influences for analysis
 * @param {number} mountainStar - Mountain star number
 * @param {number} waterStar - Water star number
 * @returns {object} Influence details
 */
function getStarInfluences(mountainStar, waterStar) {
    const mountain = FLYING_STARS[mountainStar];
    const water = FLYING_STARS[waterStar];

    return {
        mountainInfluence: mountain ? mountain.nature : 'Unknown',
        waterInfluence: water ? water.nature : 'Unknown',
        combinedEffect: calculateCombinedStarEffect(mountainStar, waterStar)
    };
}

/**
 * Calculate combined star effect
 * @param {number} mountainStar - Mountain star
 * @param {number} waterStar - Water star
 * @returns {string} Combined effect description
 */
function calculateCombinedStarEffect(mountainStar, waterStar) {
    const favorable = [6, 8, 9];
    const unfavorable = [2, 3, 7];

    const mountainFav = favorable.includes(mountainStar);
    const waterFav = favorable.includes(waterStar);
    const mountainUnfav = unfavorable.includes(mountainStar);
    const waterUnfav = unfavorable.includes(waterStar);

    if (mountainFav && waterFav) return 'Excellent combination';
    if (mountainUnfav && waterUnfav) return 'Problematic combination';
    if (mountainFav || waterFav) return 'Mixed with positive';
    if (mountainUnfav || waterUnfav) return 'Mixed with negative';

    return 'Neutral combination';
}

/**
 * Calculate mountain star based on facing direction
 * @param {number} facingDirection - Facing direction in degrees
 * @param {number} periodStar - Period star
 * @returns {number} Mountain star number
 */
function calculateMountainStar(facingDirection, periodStar) {
    // Simplified calculation - would use traditional formulas
    const normalized = normalizeDirection(facingDirection);
    const sector = Math.floor(normalized / 45) % 8;
    return ((periodStar + sector - 1) % 9) + 1;
}

/**
 * Calculate water star based on facing direction
 * @param {number} facingDirection - Facing direction in degrees
 * @param {number} periodStar - Period star
 * @returns {number} Water star number
 */
function calculateWaterStar(facingDirection, periodStar) {
    // Simplified calculation - would use traditional formulas
    const normalized = normalizeDirection(facingDirection);
    const sector = Math.floor((normalized + 180) / 45) % 8; // Opposite direction
    return ((periodStar + sector - 1) % 9) + 1;
}

/**
 * Calculate star rating based on mountain and water stars
 * @param {number} mountainStar - Mountain star
 * @param {number} waterStar - Water star
 * @returns {number} Rating score
 */
function calculateStarRating(mountainStar, waterStar) {
    const favorable = [6, 8, 9];
    const unfavorable = [2, 3, 7];

    let rating = 5.5; // Neutral

    if (favorable.includes(mountainStar)) rating += 2;
    if (favorable.includes(waterStar)) rating += 2;
    if (unfavorable.includes(mountainStar)) rating -= 2;
    if (unfavorable.includes(waterStar)) rating -= 2;

    return Math.max(1.0, Math.min(10.0, rating));
}

/**
 * Sanitize string input to prevent injection attacks
 * @param {string} input - Input string to sanitize
 * @returns {string} Sanitized string
 */
function sanitizeString(input) {
    if (typeof input !== 'string') return input;
    return input
        .replace(/[<>]/g, '') // Remove potential HTML tags
        .replace(/['"]/g, '') // Remove quotes
        .replace(/[\\]/g, '') // Remove backslashes
        .trim();
}

module.exports = {
    calculateCompassDirection,
    normalizeDirection,
    calculateBaguaArea,
    calculateElementalCompatibility,
    calculateFlyingStarInfluence,
    calculatePeriodCompatibility,
    getStarInfluences,
    calculateCombinedStarEffect,
    calculateMountainStar,
    calculateWaterStar,
    calculateStarRating,
    sanitizeString
};