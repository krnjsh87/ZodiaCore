/**
 * ZC2.3 Chinese Zodiac Compatibility Utilities
 *
 * Utility functions for mathematical operations, validation, and analysis
 *
 * @version ZC2.3-1.0
 * @author ZodiaCore Development Team
 */

const {
    CHINESE_ZODIAC_COMPATIBILITY_CONSTANTS,
    COMPATIBILITY_THRESHOLDS,
    CHINESE_ZODIAC_SIGNS,
    ELEMENT_RELATIONS,
    ERROR_MESSAGES
} = require('./chinese-zodiac-compatibility-constants');

/**
 * @typedef {Object} CompatibilityResult
 * @property {string} sign1
 * @property {string} sign2
 * @property {number} score
 * @property {string} type
 * @property {string} summary
 */

/**
 * @typedef {Object} TriangleAnalysis
 * @property {number} compatibility
 * @property {string} relationship
 * @property {number} triangle1
 * @property {number} triangle2
 * @property {string} explanation
 */

/**
 * @typedef {Object} PolarAnalysis
 * @property {number} compatibility
 * @property {string} relationship
 * @property {string} attraction
 * @property {string} polarSign1
 * @property {string} polarSign2
 * @property {string} explanation
 */

/**
 * @typedef {Object} SecretFriendAnalysis
 * @property {number} compatibility
 * @property {string} relationship
 * @property {string} friendship
 * @property {string} secretFriend1
 * @property {string} secretFriend2
 * @property {string} explanation
 */

/**
 * Normalize compatibility score to specified range
 * @param {number} score - Raw compatibility score
 * @param {number} min - Minimum allowed score (default: 1.0)
 * @param {number} max - Maximum allowed score (default: 10.0)
 * @returns {number} Normalized score within range
 */
function normalizeCompatibilityScore(score, min = 1.0, max = 10.0) {
    return Math.max(min, Math.min(max, score));
}

/**
 * Calculate weighted average of compatibility factors
 * @param {number[]} factors - Array of compatibility factor scores
 * @param {number[]} weights - Array of weights for each factor
 * @returns {number} Weighted average score
 */
function calculateWeightedCompatibility(factors, weights) {
    let totalWeight = 0;
    let weightedSum = 0;

    factors.forEach((factor, index) => {
        const weight = weights[index] || 1.0;
        weightedSum += factor * weight;
        totalWeight += weight;
    });

    return totalWeight > 0 ? weightedSum / totalWeight : CHINESE_ZODIAC_COMPATIBILITY_CONSTANTS.NEUTRAL_COMPATIBILITY_SCORE;
}

/**
 * Apply cultural bias adjustment to compatibility score
 * @param {number} baseScore - Base compatibility score
 * @param {number} traditionalBias - Cultural bias factor
 * @returns {number} Culturally adjusted score
 */
function applyCulturalBias(baseScore, traditionalBias = CHINESE_ZODIAC_COMPATIBILITY_CONSTANTS.TRADITIONAL_BIAS_FACTOR) {
    const traditionalAdjustment = (baseScore - CHINESE_ZODIAC_COMPATIBILITY_CONSTANTS.NEUTRAL_COMPATIBILITY_SCORE) * traditionalBias;
    return normalizeCompatibilityScore(baseScore + traditionalAdjustment);
}

/**
 * Calculate element compatibility score based on five-element theory
 * @param {string} element1 - First element (Wood, Fire, Earth, Metal, Water)
 * @param {string} element2 - Second element
 * @returns {number} Element compatibility multiplier (0.7-1.2)
 */
function calculateElementCompatibility(element1, element2) {
    if (element1 === element2) return 1.0; // Same element: neutral to positive
    if (ELEMENT_RELATIONS[element1].generates === element2) return 1.2; // Generates: very compatible
    if (ELEMENT_RELATIONS[element1].generatedBy === element2) return 1.1; // Generated by: supportive
    if (ELEMENT_RELATIONS[element1].controls === element2) return 0.8; // Controls: challenging
    if (ELEMENT_RELATIONS[element1].controlledBy === element2) return 0.7; // Controlled by: difficult

    return 0.9; // Neutral relationship
}

/**
 * Check if two signs have a bidirectional relationship
 * @param {string} sign1 - First sign
 * @param {string} sign2 - Second sign
 * @param {Object} relationshipMap - Relationship mapping object
 * @returns {boolean} True if bidirectional relationship exists
 */
function isBidirectionalRelationship(sign1, sign2, relationshipMap) {
    return relationshipMap[sign1] === sign2 || relationshipMap[sign2] === sign1;
}

/**
 * Normalize sign name for case-insensitive handling
 * @param {string} sign - Zodiac sign name
 * @returns {string} Normalized sign name
 */
function normalizeSign(sign) {
    if (!sign || typeof sign !== 'string') {
        throw new Error(ERROR_MESSAGES.INVALID_TYPE);
    }
    return sign.charAt(0).toUpperCase() + sign.slice(1).toLowerCase();
}

/**
 * Validate zodiac sign
 * @param {string} sign - Sign to validate
 * @throws {Error} If sign is invalid
 */
function validateSign(sign) {
    if (!sign || typeof sign !== 'string') {
        throw new Error(ERROR_MESSAGES.INVALID_TYPE);
    }

    const normalizedSign = normalizeSign(sign);
    const validSigns = CHINESE_ZODIAC_SIGNS.map(s => s.name);
    if (!validSigns.includes(normalizedSign)) {
        throw new Error(ERROR_MESSAGES.INVALID_SIGN(sign));
    }

    return normalizedSign;
}

/**
 * Validate two signs for compatibility calculation
 * @param {string} sign1 - First sign
 * @param {string} sign2 - Second sign
 * @throws {Error} If signs are invalid or identical
 */
function validateSigns(sign1, sign2) {
    const normalizedSign1 = validateSign(sign1);
    const normalizedSign2 = validateSign(sign2);

    if (normalizedSign1 === normalizedSign2) {
        throw new Error(ERROR_MESSAGES.IDENTICAL_SIGNS);
    }

    return [normalizedSign1, normalizedSign2];
}

/**
 * Calculate polarity compatibility
 * @param {string} polarity1 - First polarity
 * @param {string} polarity2 - Second polarity
 * @returns {number} Polarity compatibility score
 */
function calculatePolarityCompatibility(polarity1, polarity2) {
    if (polarity1 === polarity2) {
        return COMPATIBILITY_THRESHOLDS.POLARITY_SAME; // Same polarity: generally compatible
    } else {
        return COMPATIBILITY_THRESHOLDS.POLARITY_DIFFERENT; // Different polarity: complementary but may need adjustment
    }
}

/**
 * Calculate direction compatibility based on zodiac positioning
 * @param {number} direction1 - First direction (degrees)
 * @param {number} direction2 - Second direction (degrees)
 * @returns {number} Direction compatibility score
 */
function calculateDirectionCompatibility(direction1, direction2) {
    const angleDiff = Math.abs(direction1 - direction2);
    const normalizedDiff = Math.min(angleDiff, 360 - angleDiff);

    // Closer directions generally more compatible
    if (normalizedDiff <= 30) return COMPATIBILITY_THRESHOLDS.DIRECTION_VERY_CLOSE;      // Very close
    if (normalizedDiff <= 60) return COMPATIBILITY_THRESHOLDS.DIRECTION_CLOSE;      // Close
    if (normalizedDiff <= 120) return COMPATIBILITY_THRESHOLDS.DIRECTION_MODERATE;     // Moderate distance
    if (normalizedDiff <= 180) return COMPATIBILITY_THRESHOLDS.DIRECTION_OPPOSITE;     // Opposite-ish

    return COMPATIBILITY_THRESHOLDS.DIRECTION_OTHER; // Other relationships
}

/**
 * Limited cache with LRU eviction
 */
class LimitedCache extends Map {
    /**
     * @param {number} maxSize - Maximum cache size
     */
    constructor(maxSize = CHINESE_ZODIAC_COMPATIBILITY_CONSTANTS.MAX_CACHE_SIZE) {
        super();
        this.maxSize = maxSize;
    }

    /**
     * Set a key-value pair with LRU eviction
     * @param {*} key
     * @param {*} value
     * @returns {Map}
     */
    set(key, value) {
        if (this.size >= this.maxSize) {
            const firstKey = this.keys().next().value;
            this.delete(firstKey);
        }
        return super.set(key, value);
    }
}

module.exports = {
    normalizeCompatibilityScore,
    calculateWeightedCompatibility,
    applyCulturalBias,
    calculateElementCompatibility,
    isBidirectionalRelationship,
    normalizeSign,
    validateSign,
    validateSigns,
    calculatePolarityCompatibility,
    calculateDirectionCompatibility,
    LimitedCache
};