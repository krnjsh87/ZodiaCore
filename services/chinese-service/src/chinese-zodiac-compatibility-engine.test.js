/**
 * Unit Tests for ZC2.3 Chinese Zodiac Compatibility Engine
 *
 * Comprehensive test suite covering all functionality with 80%+ code coverage
 */

const {
    ZodiacCompatibilityEngine,
    CHINESE_ZODIAC_COMPATIBILITY_CONSTANTS,
    CHINESE_ZODIAC_SIGNS,
    TRIANGLE_GROUPS,
    POLAR_RELATIONSHIPS,
    SECRET_FRIENDS,
    calculateComprehensiveCompatibility,
    analyzeTriangleCompatibility,
    analyzePolarCompatibility,
    analyzeSecretFriendCompatibility,
    calculateElementCompatibility,
    normalizeCompatibilityScore,
    calculateWeightedCompatibility,
    applyCulturalBias,
    ZodiacCompatibilityError,
    ValidationError
} = require('./chinese-zodiac-compatibility-engine');

describe('Chinese Zodiac Compatibility Engine', () => {

    // ============================================================================
    // CONSTANTS AND DATA STRUCTURE TESTS
    // ============================================================================

    describe('Constants and Data Structures', () => {
        test('should have correct compatibility constants', () => {
            expect(CHINESE_ZODIAC_COMPATIBILITY_CONSTANTS.MAX_COMPATIBILITY_SCORE).toBe(10.0);
            expect(CHINESE_ZODIAC_COMPATIBILITY_CONSTANTS.MIN_COMPATIBILITY_SCORE).toBe(1.0);
            expect(CHINESE_ZODIAC_COMPATIBILITY_CONSTANTS.NEUTRAL_COMPATIBILITY_SCORE).toBe(5.5);
            expect(CHINESE_ZODIAC_COMPATIBILITY_CONSTANTS.TRIANGLE_COMPATIBILITY_WEIGHT).toBe(2.0);
            expect(CHINESE_ZODIAC_COMPATIBILITY_CONSTANTS.TRADITIONAL_BIAS_FACTOR).toBe(0.15);
        });

        test('should have all 12 zodiac signs with correct properties', () => {
            expect(CHINESE_ZODIAC_SIGNS).toHaveLength(12);
            expect(CHINESE_ZODIAC_SIGNS[0]).toEqual({
                name: 'Rat',
                element: 'Water',
                polarity: 'Yang',
                direction: 0,
                triangle: 0
            });
            expect(CHINESE_ZODIAC_SIGNS[11]).toEqual({
                name: 'Pig',
                element: 'Water',
                polarity: 'Yin',
                direction: 330,
                triangle: 3
            });
        });

        test('should have correct triangle groups', () => {
            expect(TRIANGLE_GROUPS).toHaveLength(4);
            expect(TRIANGLE_GROUPS[0]).toEqual(['Rat', 'Dragon', 'Monkey']);
            expect(TRIANGLE_GROUPS[3]).toEqual(['Rabbit', 'Pig', 'Dog']);
        });

        test('should have correct polar relationships', () => {
            expect(POLAR_RELATIONSHIPS.Rat).toBe('Horse');
            expect(POLAR_RELATIONSHIPS.Horse).toBe('Rat');
            expect(POLAR_RELATIONSHIPS.Dragon).toBe('Dog');
        });

        test('should have correct secret friends', () => {
            expect(SECRET_FRIENDS.Rat).toBe('Ox');
            expect(SECRET_FRIENDS.Ox).toBe('Rat');
            expect(SECRET_FRIENDS.Tiger).toBe('Pig');
        });
    });

    // ============================================================================
    // MATHEMATICAL FUNCTION TESTS
    // ============================================================================

    describe('Mathematical Functions', () => {
        test('normalizeCompatibilityScore should clamp values correctly', () => {
            expect(normalizeCompatibilityScore(15)).toBe(10.0);
            expect(normalizeCompatibilityScore(-5)).toBe(1.0);
            expect(normalizeCompatibilityScore(7.5)).toBe(7.5);
        });

        test('calculateWeightedCompatibility should compute correct weighted average', () => {
            const factors = [8.0, 6.0, 7.0];
            const weights = [2.0, 1.0, 1.5];
            const result = calculateWeightedCompatibility(factors, weights);
            expect(result).toBeCloseTo(7.125, 3);
        });

        test('applyCulturalBias should adjust score correctly', () => {
            const result = applyCulturalBias(8.0);
            expect(result).toBeCloseTo(8.12, 2); // 8.0 + (8.0 - 5.5) * 0.15
        });

        test('calculateElementCompatibility should return correct multipliers', () => {
            expect(calculateElementCompatibility('Wood', 'Fire')).toBe(1.2); // Generates
            expect(calculateElementCompatibility('Wood', 'Water')).toBe(1.1); // Generated by
            expect(calculateElementCompatibility('Wood', 'Earth')).toBe(0.8); // Controls
            expect(calculateElementCompatibility('Wood', 'Metal')).toBe(0.7); // Controlled by
            expect(calculateElementCompatibility('Wood', 'Wood')).toBe(1.0); // Same
            expect(calculateElementCompatibility('Wood', 'Wood')).toBe(1.0); // Neutral
        });
    });

    // ============================================================================
    // COMPATIBILITY ANALYSIS TESTS
    // ============================================================================

    describe('Compatibility Analysis Functions', () => {
        test('analyzeTriangleCompatibility should identify triangle allies', () => {
            const result = analyzeTriangleCompatibility('Rat', 'Dragon');
            expect(result.compatibility).toBe(9.0);
            expect(result.relationship).toBe('triangle_adjacent');
            expect(result.triangle1).toBe(0);
            expect(result.triangle2).toBe(0);
        });

        test('analyzeTriangleCompatibility should identify triangle neutrals', () => {
            const result = analyzeTriangleCompatibility('Rat', 'Ox');
            expect(result.compatibility).toBe(6.5);
            expect(result.relationship).toBe('triangle_neutral');
        });

        test('analyzePolarCompatibility should identify polar opposites', () => {
            const result = analyzePolarCompatibility('Rat', 'Horse');
            expect(result.compatibility).toBe(7.5);
            expect(result.relationship).toBe('polar_opposite');
            expect(result.attraction).toBe('strong');
        });

        test('analyzePolarCompatibility should handle non-polar relationships', () => {
            const result = analyzePolarCompatibility('Rat', 'Ox');
            expect(result.relationship).toBe('non_polar');
            expect(result.attraction).toBe('neutral');
        });

        test('analyzeSecretFriendCompatibility should identify secret friends', () => {
            const result = analyzeSecretFriendCompatibility('Rat', 'Ox');
            expect(result.compatibility).toBe(8.5);
            expect(result.relationship).toBe('secret_friend');
            expect(result.friendship).toBe('deep');
        });

        test('analyzeSecretFriendCompatibility should handle non-secret friends', () => {
            const result = analyzeSecretFriendCompatibility('Rat', 'Tiger');
            expect(result.relationship).toBe('neutral');
            expect(result.friendship).toBe('casual');
        });
    });

    // ============================================================================
    // COMPREHENSIVE COMPATIBILITY TESTS
    // ============================================================================

    describe('Comprehensive Compatibility Calculation', () => {
        test('calculateComprehensiveCompatibility should return complete analysis', () => {
            const result = calculateComprehensiveCompatibility('Rat', 'Dragon');

            expect(result.sign1).toBe('Rat');
            expect(result.sign2).toBe('Dragon');
            expect(result.overallScore).toBeGreaterThanOrEqual(1.0);
            expect(result.overallScore).toBeLessThanOrEqual(10.0);
            expect(result.relationshipType).toBe('triangle_adjacent');
            expect(result.breakdown).toHaveProperty('triangle');
            expect(result.breakdown).toHaveProperty('polar');
            expect(result.breakdown).toHaveProperty('secretFriend');
            expect(result.breakdown).toHaveProperty('element');
            expect(result.analysis).toHaveProperty('summary');
            expect(result.analysis).toHaveProperty('strengths');
            expect(result.analysis).toHaveProperty('challenges');
            expect(result.analysis).toHaveProperty('recommendations');
        });

        test('calculateComprehensiveCompatibility should handle secret friends priority', () => {
            const result = calculateComprehensiveCompatibility('Rat', 'Ox');
            expect(result.relationshipType).toBe('secret_friend');
        });

        test('calculateComprehensiveCompatibility should handle polar opposites', () => {
            const result = calculateComprehensiveCompatibility('Rat', 'Horse');
            expect(result.relationshipType).toBe('polar_opposite');
        });

        test('calculateComprehensiveCompatibility should throw error for invalid signs', () => {
            expect(() => calculateComprehensiveCompatibility('Invalid', 'Rat')).toThrow('Invalid zodiac signs provided');
            expect(() => calculateComprehensiveCompatibility('Rat', 'Invalid')).toThrow('Invalid zodiac signs provided');
        });
    });

    // ============================================================================
    // ZODIAC COMPATIBILITY ENGINE TESTS
    // ============================================================================

    describe('ZodiacCompatibilityEngine Class', () => {
        let engine;

        beforeEach(() => {
            engine = new ZodiacCompatibilityEngine();
        });

        test('should initialize with default settings', () => {
            expect(engine.constants).toBeDefined();
            expect(engine.matrix).toBeNull();
            expect(engine.customWeights).toEqual({});
            expect(engine.cache).toBeInstanceOf(Map);
        });

        test('should initialize with matrix when enabled', () => {
            const matrixEngine = new ZodiacCompatibilityEngine({ useMatrix: true });
            expect(matrixEngine.matrix).toBeDefined();
            expect(matrixEngine.matrix.Rat).toBeDefined();
            expect(matrixEngine.matrix.Rat.Dragon).toBeDefined();
        });

        test('should initialize with custom weights', () => {
            const customWeights = { triangle: 3.0, element: 2.0 };
            const weightedEngine = new ZodiacCompatibilityEngine({ weights: customWeights });
            expect(weightedEngine.customWeights).toEqual(customWeights);
        });

        test('calculateCompatibility should return valid results', () => {
            const result = engine.calculateCompatibility('Rat', 'Dragon');
            expect(result.sign1).toBe('Rat');
            expect(result.sign2).toBe('Dragon');
            expect(result.score).toBeDefined();
            expect(result.type).toBeDefined();
            expect(result.summary).toBeDefined();
        });

        test('calculateCompatibility should use cache', () => {
            engine.calculateCompatibility('Rat', 'Dragon');
            expect(engine.cache.has('Rat-Dragon')).toBe(true);

            const result = engine.calculateCompatibility('Rat', 'Dragon');
            expect(result.source).toBe('calculated');
        });

        test('calculateCompatibility should validate inputs', () => {
            expect(() => engine.calculateCompatibility('Invalid', 'Rat')).toThrow(ValidationError);
            expect(() => engine.calculateCompatibility('Rat', 'Rat')).toThrow(ValidationError);
        });

        test('getCompatibilityTrends should return trend analysis', () => {
            const trends = engine.getCompatibilityTrends('Rat');
            expect(trends.sign).toBe('Rat');
            expect(trends.bestMatches).toBeInstanceOf(Array);
            expect(trends.challengingMatches).toBeInstanceOf(Array);
            expect(trends.averageScore).toBeGreaterThan(0);
            expect(trends.distribution).toHaveProperty('excellent');
            expect(trends.distribution).toHaveProperty('good');
            expect(trends.distribution).toHaveProperty('moderate');
            expect(trends.distribution).toHaveProperty('challenging');
        });

        test('getCompatibilityTrends should validate sign', () => {
            expect(() => engine.getCompatibilityTrends('Invalid')).toThrow(ValidationError);
        });

        test('calculateWeightedCompatibilityScore should apply custom weights', () => {
            const customWeights = { triangle: 3.0, polar: 0.5 };
            const result = engine.calculateWeightedCompatibilityScore('Rat', 'Dragon', customWeights);
            expect(result.overallScore).toBeDefined();
            expect(result.breakdown.triangle.weight).toBe(3.0);
            expect(result.breakdown.polar.weight).toBe(0.5);
        });

        test('calculatePolarityCompatibility should return correct scores', () => {
            expect(engine.calculatePolarityCompatibility('Yang', 'Yang')).toBe(7.0);
            expect(engine.calculatePolarityCompatibility('Yang', 'Yin')).toBe(6.0);
        });

        test('calculateDirectionCompatibility should return correct scores', () => {
            expect(engine.calculateDirectionCompatibility(0, 30)).toBe(8.0); // Very close
            expect(engine.calculateDirectionCompatibility(0, 180)).toBe(5.5); // Opposite
        });

        test('clearCache should clear the cache', () => {
            engine.calculateCompatibility('Rat', 'Dragon');
            expect(engine.cache.size).toBe(1);
            engine.clearCache();
            expect(engine.cache.size).toBe(0);
        });

        test('getStatistics should return engine stats', () => {
            const stats = engine.getStatistics();
            expect(stats).toHaveProperty('cacheSize');
            expect(stats).toHaveProperty('calculationsPerformed');
            expect(stats).toHaveProperty('matrixEnabled');
            expect(stats).toHaveProperty('customWeights');
        });
    });

    // ============================================================================
    // VALIDATION TESTS
    // ============================================================================

    describe('Validation', () => {
        let validator;

        beforeEach(() => {
            validator = new ZodiacCompatibilityValidator();
        });

        test('validateSign should accept valid signs', () => {
            expect(() => validator.validateSign('Rat')).not.toThrow();
            expect(() => validator.validateSign('Dragon')).not.toThrow();
        });

        test('validateSign should reject invalid signs', () => {
            expect(() => validator.validateSign('')).toThrow(ValidationError);
            expect(() => validator.validateSign(null)).toThrow(ValidationError);
            expect(() => validator.validateSign('Invalid')).toThrow(ValidationError);
            expect(() => validator.validateSign(123)).toThrow(ValidationError);
        });

        test('validateSigns should reject identical signs', () => {
            expect(() => validator.validateSigns('Rat', 'Rat')).toThrow(ValidationError);
        });
    });

    // ============================================================================
    // ERROR HANDLING TESTS
    // ============================================================================

    describe('Error Handling', () => {
        test('ZodiacCompatibilityError should have correct properties', () => {
            const error = new ZodiacCompatibilityError('Test error', 'TEST_CODE');
            expect(error.message).toBe('Test error');
            expect(error.code).toBe('TEST_CODE');
            expect(error.name).toBe('ZodiacCompatibilityError');
        });

        test('ValidationError should extend ZodiacCompatibilityError', () => {
            const error = new ValidationError('Validation failed');
            expect(error).toBeInstanceOf(ZodiacCompatibilityError);
            expect(error.code).toBe('VALIDATION_ERROR');
        });
    });

    // ============================================================================
    // INTEGRATION TESTS
    // ============================================================================

    describe('Integration Tests', () => {
        test('full compatibility analysis should be consistent', () => {
            const engine = new ZodiacCompatibilityEngine({ useMatrix: true });

            // Test multiple pairs for consistency
            const pairs = [
                ['Rat', 'Dragon'],
                ['Ox', 'Snake'],
                ['Tiger', 'Horse'],
                ['Rabbit', 'Goat'],
                ['Snake', 'Rooster'],
                ['Horse', 'Goat']
            ];

            pairs.forEach(([sign1, sign2]) => {
                const result1 = engine.calculateCompatibility(sign1, sign2);
                const result2 = engine.calculateCompatibility(sign1, sign2);

                expect(result1.score).toBe(result2.score);
                expect(result1.type).toBe(result2.type);
            });
        });

        test('engine should handle high load gracefully', () => {
            const engine = new ZodiacCompatibilityEngine();

            // Simulate multiple calculations
            for (let i = 0; i < 100; i++) {
                const sign1 = CHINESE_ZODIAC_SIGNS[i % 12].name;
                const sign2 = CHINESE_ZODIAC_SIGNS[(i + 1) % 12].name;
                const result = engine.calculateCompatibility(sign1, sign2);
                expect(result.score).toBeDefined();
            }

            expect(engine.cache.size).toBeGreaterThan(0);
        });

        test('all zodiac sign combinations should be calculable', () => {
            const engine = new ZodiacCompatibilityEngine();
            const signs = CHINESE_ZODIAC_SIGNS.map(s => s.name);

            signs.forEach(sign1 => {
                signs.forEach(sign2 => {
                    if (sign1 !== sign2) {
                        const result = engine.calculateCompatibility(sign1, sign2);
                        expect(result.score).toBeGreaterThanOrEqual(1.0);
                        expect(result.score).toBeLessThanOrEqual(10.0);
                        expect(['triangle_ally', 'triangle_adjacent', 'polar_opposite', 'secret_friend', 'neutral']).toContain(result.type);
                    }
                });
            });
        });
    });

    // ============================================================================
    // EDGE CASE AND BOUNDARY TESTS
    // ============================================================================

    describe('Edge Cases and Boundary Conditions', () => {
        test('should handle all triangle combinations correctly', () => {
            const engine = new ZodiacCompatibilityEngine();
            const triangles = TRIANGLE_GROUPS;

            // Test all combinations within each triangle
            triangles.forEach(triangle => {
                for (let i = 0; i < triangle.length; i++) {
                    for (let j = i + 1; j < triangle.length; j++) {
                        const result = engine.calculateCompatibility(triangle[i], triangle[j]);
                        expect(result.type).toMatch(/^triangle_/);
                        expect(result.score).toBeGreaterThanOrEqual(8.0);
                    }
                }
            });
        });

        test('should handle all polar relationships correctly', () => {
            const engine = new ZodiacCompatibilityEngine();

            Object.entries(POLAR_RELATIONSHIPS).forEach(([sign1, sign2]) => {
                const result = engine.calculateCompatibility(sign1, sign2);
                expect(result.type).toBe('polar_opposite');
                expect(result.score).toBeGreaterThanOrEqual(7.5);
                expect(result.score).toBeLessThanOrEqual(8.0);
            });
        });

        test('should handle all secret friend relationships correctly', () => {
            const engine = new ZodiacCompatibilityEngine();

            Object.entries(SECRET_FRIENDS).forEach(([sign1, sign2]) => {
                const result = engine.calculateCompatibility(sign1, sign2);
                expect(result.type).toBe('secret_friend');
                expect(result.score).toBeGreaterThanOrEqual(8.5);
            });
        });

        test('should handle same element pairs with appropriate scores', () => {
            const engine = new ZodiacCompatibilityEngine();
            const elements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water'];

            elements.forEach(element => {
                const sameElementSigns = CHINESE_ZODIAC_SIGNS.filter(s => s.element === element);
                sameElementSigns.forEach(sign1 => {
                    sameElementSigns.forEach(sign2 => {
                        if (sign1.name !== sign2.name) {
                            const result = engine.calculateCompatibility(sign1.name, sign2.name);
                            // Same element should contribute positively but not override other factors
                            expect(result.breakdown.element.compatibility).toBe(10.0);
                        }
                    });
                });
            });
        });

        test('should handle extreme polarity differences', () => {
            const engine = new ZodiacCompatibilityEngine();

            // Yin-Yang polarity differences
            const yinSigns = CHINESE_ZODIAC_SIGNS.filter(s => s.polarity === 'Yin').map(s => s.name);
            const yangSigns = CHINESE_ZODIAC_SIGNS.filter(s => s.polarity === 'Yang').map(s => s.name);

            yinSigns.forEach(yinSign => {
                yangSigns.forEach(yangSign => {
                    const result = engine.calculateCompatibility(yinSign, yangSign);
                    expect(result.breakdown.polarity.score).toBe(6.0);
                });
            });
        });

        test('should handle direction proximity correctly', () => {
            const engine = new ZodiacCompatibilityEngine();

            // Test close directions (adjacent signs)
            const result1 = engine.calculateCompatibility('Rat', 'Ox'); // 0째 and 30째
            expect(result1.breakdown.direction.score).toBe(8.0);

            // Test opposite directions
            const result2 = engine.calculateCompatibility('Rat', 'Horse'); // 0째 and 180째
            expect(result2.breakdown.direction.score).toBe(5.5);
        });

        test('should handle minimum and maximum compatibility scores', () => {
            const engine = new ZodiacCompatibilityEngine();

            // Test all combinations to ensure scores stay within bounds
            const signs = CHINESE_ZODIAC_SIGNS.map(s => s.name);

            signs.forEach(sign1 => {
                signs.forEach(sign2 => {
                    if (sign1 !== sign2) {
                        const result = engine.calculateCompatibility(sign1, sign2);
                        expect(result.score).toBeGreaterThanOrEqual(1.0);
                        expect(result.score).toBeLessThanOrEqual(10.0);
                        expect(result.overallScore).toBeGreaterThanOrEqual(1.0);
                        expect(result.overallScore).toBeLessThanOrEqual(10.0);
                    }
                });
            });
        });
    });

    // ============================================================================
    // CULTURAL ACCURACY VERIFICATION TESTS
    // ============================================================================

    describe('Cultural Accuracy Verification', () => {
        test('should match traditional triangle compatibility expectations', () => {
            const engine = new ZodiacCompatibilityEngine();

            // Rat-Monkey (same triangle, adjacent)
            const ratMonkey = engine.calculateCompatibility('Rat', 'Monkey');
            expect(ratMonkey.type).toBe('triangle_adjacent');
            expect(ratMonkey.score).toBeGreaterThanOrEqual(9.0);

            // Ox-Rooster (same triangle, adjacent)
            const oxRooster = engine.calculateCompatibility('Ox', 'Rooster');
            expect(oxRooster.type).toBe('triangle_adjacent');
            expect(oxRooster.score).toBeGreaterThanOrEqual(9.0);

            // Tiger-Goat (same triangle, adjacent)
            const tigerGoat = engine.calculateCompatibility('Tiger', 'Goat');
            expect(tigerGoat.type).toBe('triangle_adjacent');
            expect(tigerGoat.score).toBeGreaterThanOrEqual(9.0);

            // Rabbit-Dog (same triangle, adjacent)
            const rabbitDog = engine.calculateCompatibility('Rabbit', 'Dog');
            expect(rabbitDog.type).toBe('triangle_adjacent');
            expect(rabbitDog.score).toBeGreaterThanOrEqual(9.0);
        });

        test('should match traditional polar relationship expectations', () => {
            const engine = new ZodiacCompatibilityEngine();

            // Rat-Horse (polar opposites)
            const ratHorse = engine.calculateCompatibility('Rat', 'Horse');
            expect(ratHorse.type).toBe('polar_opposite');
            expect(ratHorse.analysis.strengths).toContain('Exciting attraction and growth opportunities');

            // Dragon-Dog (polar opposites)
            const dragonDog = engine.calculateCompatibility('Dragon', 'Dog');
            expect(dragonDog.type).toBe('polar_opposite');
            expect(dragonDog.analysis.challenges).toContain('Potential for conflict and misunderstanding');
        });

        test('should match traditional secret friend expectations', () => {
            const engine = new ZodiacCompatibilityEngine();

            // Rat-Ox (secret friends)
            const ratOx = engine.calculateCompatibility('Rat', 'Ox');
            expect(ratOx.type).toBe('secret_friend');
            expect(ratOx.analysis.strengths).toContain('Deep, unspoken understanding');

            // Tiger-Pig (secret friends)
            const tigerPig = engine.calculateCompatibility('Tiger', 'Pig');
            expect(tigerPig.type).toBe('secret_friend');
            expect(tigerPig.analysis.strengths).toContain('Deep, unspoken understanding');
        });

        test('should provide culturally appropriate explanations', () => {
            const engine = new ZodiacCompatibilityEngine();

            const relationships = [
                { signs: ['Rat', 'Dragon'], type: 'triangle_adjacent' },
                { signs: ['Rat', 'Horse'], type: 'polar_opposite' },
                { signs: ['Rat', 'Ox'], type: 'secret_friend' }
            ];

            relationships.forEach(({ signs, type }) => {
                const result = engine.calculateCompatibility(signs[0], signs[1]);
                expect(result.type).toBe(type);
                expect(result.analysis.summary).toBeDefined();
                expect(result.analysis.strengths.length).toBeGreaterThan(0);
                expect(typeof result.analysis.summary).toBe('string');
            });
        });
    });

    // ============================================================================
    // VALIDATION AND ERROR HANDLING TESTS
    // ============================================================================

    describe('Validation and Error Handling', () => {
        test('should reject invalid zodiac signs', () => {
            const engine = new ZodiacCompatibilityEngine();

            const invalidSigns = ['', null, undefined, 123, {}, [], 'invalid', 'Cat', 'Lion'];

            invalidSigns.forEach(invalidSign => {
                expect(() => engine.calculateCompatibility(invalidSign, 'Rat')).toThrow(ValidationError);
                expect(() => engine.calculateCompatibility('Rat', invalidSign)).toThrow(ValidationError);
                expect(() => engine.getCompatibilityTrends(invalidSign)).toThrow(ValidationError);
            });
        });

        test('should reject identical signs', () => {
            const engine = new ZodiacCompatibilityEngine();

            CHINESE_ZODIAC_SIGNS.forEach(sign => {
                expect(() => engine.calculateCompatibility(sign.name, sign.name)).toThrow(ValidationError);
            });
        });

        test('should handle case-insensitive input correctly', () => {
            const engine = new ZodiacCompatibilityEngine();

            const variations = ['rat', 'RAT', 'Rat', 'rAt'];

            variations.forEach(variation => {
                const result = engine.calculateCompatibility(variation, 'Dragon');
                expect(result.sign1).toBe('Rat');
                expect(result.sign2).toBe('Dragon');
                expect(result.score).toBeDefined();
            });
        });

        test('should handle whitespace and normalization', () => {
            const engine = new ZodiacCompatibilityEngine();

            const inputs = [' rat ', ' RAT ', ' rAt '];

            inputs.forEach(input => {
                const result = engine.calculateCompatibility(input, 'Dragon');
                expect(result.sign1).toBe('Rat');
                expect(result.sign2).toBe('Dragon');
            });
        });

        test('should provide meaningful error messages', () => {
            const engine = new ZodiacCompatibilityEngine();

            try {
                engine.calculateCompatibility('Invalid', 'Rat');
                fail('Should have thrown an error');
            } catch (error) {
                expect(error).toBeInstanceOf(ValidationError);
                expect(error.message).toContain('Invalid zodiac sign');
                expect(error.message).toContain('Valid signs');
            }
        });

        test('should handle engine errors gracefully', () => {
            const engine = new ZodiacCompatibilityEngine();

            // Test with corrupted internal state (simulate error)
            const originalSigns = CHINESE_ZODIAC_SIGNS;
            // Temporarily corrupt the signs array
            require.cache[require.resolve('./chinese-zodiac-compatibility-constants')].exports.CHINESE_ZODIAC_SIGNS = [];

            try {
                expect(() => engine.calculateCompatibility('Rat', 'Dragon')).toThrow();
            } finally {
                // Restore original state
                require.cache[require.resolve('./chinese-zodiac-compatibility-constants')].exports.CHINESE_ZODIAC_SIGNS = originalSigns;
            }
        });
    });

    // ============================================================================
    // PERFORMANCE TESTS
    // ============================================================================

    describe('Performance Tests', () => {
        test('single calculation should be fast', () => {
            const engine = new ZodiacCompatibilityEngine();
            const startTime = Date.now();

            engine.calculateCompatibility('Rat', 'Dragon');

            const endTime = Date.now();
            const duration = endTime - startTime;

            expect(duration).toBeLessThan(50); // Should complete in less than 50ms
        });

        test('matrix generation should be reasonably fast', () => {
            const startTime = Date.now();

            const engine = new ZodiacCompatibilityEngine({ useMatrix: true });

            const endTime = Date.now();
            const duration = endTime - startTime;

            expect(duration).toBeLessThan(500); // Should complete in less than 500ms
        });

        test('cached calculations should be very fast', () => {
            const engine = new ZodiacCompatibilityEngine();

            // First calculation (uncached)
            engine.calculateCompatibility('Rat', 'Dragon');
            const startTime = Date.now();

            // Second calculation (cached)
            engine.calculateCompatibility('Rat', 'Dragon');

            const endTime = Date.now();
            const duration = endTime - startTime;

            expect(duration).toBeLessThan(5); // Should complete in less than 5ms
        });

        test('should handle concurrent calculations efficiently', () => {
            const engine = new ZodiacCompatibilityEngine();
            const promises = [];

            // Create multiple concurrent calculations
            for (let i = 0; i < 50; i++) {
                const sign1 = CHINESE_ZODIAC_SIGNS[i % 12].name;
                const sign2 = CHINESE_ZODIAC_SIGNS[(i + 1) % 12].name;
                promises.push(engine.calculateCompatibility(sign1, sign2));
            }

            const startTime = Date.now();

            return Promise.all(promises).then(results => {
                const endTime = Date.now();
                const duration = endTime - startTime;

                expect(duration).toBeLessThan(1000); // Should complete in less than 1 second
                expect(results).toHaveLength(50);
                results.forEach(result => {
                    expect(result.score).toBeDefined();
                });
            });
        });

        test('memory usage should remain stable', () => {
            const engine = new ZodiacCompatibilityEngine();

            // Perform many calculations
            for (let i = 0; i < 1000; i++) {
                const sign1 = CHINESE_ZODIAC_SIGNS[i % 12].name;
                const sign2 = CHINESE_ZODIAC_SIGNS[(i + 1) % 12].name;
                engine.calculateCompatibility(sign1, sign2);
            }

            // Cache should not grow unbounded
            expect(engine.cache.size).toBeLessThanOrEqual(1000);
        });
    });
});